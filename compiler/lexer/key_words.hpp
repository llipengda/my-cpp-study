#pragma once
#ifndef LEXER_KEY_WORDS_HPP
#define LEXER_KEY_WORDS_HPP

#include "../regex/regex.hpp"
#include <utility>
#include <vector>

namespace lexer::token {
enum token_type {
    AUTO = 1,
    BREAK,
    CASE,
    CHAR,
    CONST,
    CONTINUE,
    DEFAULT,
    DO,
    DOUBLE,
    ELSE,
    ENUM,
    EXTERN,
    FLOAT,
    FOR,
    GOTO,
    IF,
    INT,
    LONG,
    REGISTER,
    RETURN,
    SHORT,
    SIGNED,
    SIZEOF,
    STATIC,
    STRUCT,
    SWITCH,
    TYPEDEF,
    UNION,
    UNSIGNED,
    VOID,
    VOLATILE,
    WHILE,
    MINUS,
    MINUS_MINUS,
    MINUS_EQUAL,
    ARROW,
    BANG,
    BANG_EQUAL,
    PERCENT,
    PERCENT_EQUAL,
    AMPERSAND,
    AMPERSAND_AMPERSAND,
    AMPERSAND_EQUAL,
    LPAREN,
    RPAREN,
    ASTERISK,
    ASTERISK_EQUAL,
    COMMA,
    DOT,
    SLASH,
    SLASH_EQUAL,
    COLON,
    SEMICOLON,
    QUESTION,
    LBRACKET,
    RBRACKET,
    CARET,
    CARET_EQUAL,
    LBRACE,
    PIPE,
    PIPE_PIPE,
    PIPE_EQUAL,
    RBRACE,
    TILDE,
    PLUS,
    PLUS_PLUS,
    PLUS_EQUAL,
    LESS,
    LESS_LESS,
    LESS_LESS_EQUAL,
    LESS_EQUAL,
    EQUAL,
    EQUAL_EQUAL,
    GREATER,
    GREATER_EQUAL,
    GREATER_GREATER,
    GREATER_GREATER_EQUAL,
    QUOTE,
    COMMENT,
    NUMBER,
    IDENTIFIER,
    WHITESPACE
};

using key_word_t = std::pair<regex::regex, token_type>;

static const std::vector<key_word_t> key_words = {
    {regex::regex("auto"), AUTO},
    {regex::regex("break"), BREAK},
    {regex::regex("case"), CASE},
    {regex::regex("char"), CHAR},
    {regex::regex("const"), CONST},
    {regex::regex("continue"), CONTINUE},
    {regex::regex("default"), DEFAULT},
    {regex::regex("do"), DO},
    {regex::regex("double"), DOUBLE},
    {regex::regex("else"), ELSE},
    {regex::regex("enum"), ENUM},
    {regex::regex("extern"), EXTERN},
    {regex::regex("float"), FLOAT},
    {regex::regex("for"), FOR},
    {regex::regex("goto"), GOTO},
    {regex::regex("if"), IF},
    {regex::regex("int"), INT},
    {regex::regex("long"), LONG},
    {regex::regex("register"), REGISTER},
    {regex::regex("return"), RETURN},
    {regex::regex("short"), SHORT},
    {regex::regex("signed"), SIGNED},
    {regex::regex("sizeof"), SIZEOF},
    {regex::regex("static"), STATIC},
    {regex::regex("struct"), STRUCT},
    {regex::regex("switch"), SWITCH},
    {regex::regex("typedef"), TYPEDEF},
    {regex::regex("union"), UNION},
    {regex::regex("unsigned"), UNSIGNED},
    {regex::regex("void"), VOID},
    {regex::regex("volatile"), VOLATILE},
    {regex::regex("while"), WHILE},
    {regex::regex("-"), MINUS},
    {regex::regex("--"), MINUS_MINUS},
    {regex::regex("-="), MINUS_EQUAL},
    {regex::regex("->"), ARROW},
    {regex::regex("!"), BANG},
    {regex::regex("!="), BANG_EQUAL},
    {regex::regex("%"), PERCENT},
    {regex::regex("%="), PERCENT_EQUAL},
    {regex::regex("&"), AMPERSAND},
    {regex::regex("&&"), AMPERSAND_AMPERSAND},
    {regex::regex("&="), AMPERSAND_EQUAL},
    {regex::regex("\\("), LPAREN},
    {regex::regex("\\)"), RPAREN},
    {regex::regex("\\*"), ASTERISK},
    {regex::regex("\\*="), ASTERISK_EQUAL},
    {regex::regex(","), COMMA},
    {regex::regex("."), DOT},
    {regex::regex("/"), SLASH},
    {regex::regex("/="), SLASH_EQUAL},
    {regex::regex(":"), COLON},
    {regex::regex(";"), SEMICOLON},
    {regex::regex("?"), QUESTION},
    {regex::regex("\\["), LBRACKET},
    {regex::regex("\\]"), RBRACKET},
    {regex::regex("^"), CARET},
    {regex::regex("^="), CARET_EQUAL},
    {regex::regex("{"), LBRACE},
    {regex::regex("\\|"), PIPE},
    {regex::regex("\\|\\|"), PIPE_PIPE},
    {regex::regex("\\|="), PIPE_EQUAL},
    {regex::regex("}"), RBRACE},
    {regex::regex("~"), TILDE},
    {regex::regex("\\+"), PLUS},
    {regex::regex("\\+\\+"), PLUS_PLUS},
    {regex::regex("\\+="), PLUS_EQUAL},
    {regex::regex("<"), LESS},
    {regex::regex("<<"), LESS_LESS},
    {regex::regex("<<="), LESS_LESS_EQUAL},
    {regex::regex("<="), LESS_EQUAL},
    {regex::regex("="), EQUAL},
    {regex::regex("=="), EQUAL_EQUAL},
    {regex::regex(">"), GREATER},
    {regex::regex(">="), GREATER_EQUAL},
    {regex::regex(">>"), GREATER_GREATER},
    {regex::regex(">>="), GREATER_GREATER_EQUAL},
    {regex::regex("\""), QUOTE},
    {regex::regex("(//[^\n]*)|(/\\*([^*]|\\*+[^*/])*\\*+/)"), COMMENT},
    {regex::regex("[0-9]+"), NUMBER},
    {regex::regex("[a-zA-Z_%][a-zA-Z0-9_]*"), IDENTIFIER},
    {regex::regex("[ \t\r\n]+"), WHITESPACE}};
} // namespace lexer::token

#endif // LEXER_KEY_WORDS_HPP
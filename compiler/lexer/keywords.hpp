#pragma once
#ifndef LEXER_KEYWORDS_HPP
#define LEXER_KEYWORDS_HPP
#include "../regex/regex.hpp"
#include "token.hpp"
#include <utility>

namespace lexer {
using key_word_t = std::pair<regex::regex, token_type>;

static const std::vector<key_word_t> key_words = {
    {regex::regex("auto"), AUTO},
    {regex::regex("break"), BREAK},
    {regex::regex("case"), CASE},
    {regex::regex("char"), CHAR},
    {regex::regex("const"), CONST},
    {regex::regex("continue"), CONTINUE},
    {regex::regex("default"), DEFAULT},
    {regex::regex("do"), DO},
    {regex::regex("double"), DOUBLE},
    {regex::regex("else"), ELSE},
    {regex::regex("enum"), ENUM},
    {regex::regex("extern"), EXTERN},
    {regex::regex("float"), FLOAT},
    {regex::regex("for"), FOR},
    {regex::regex("goto"), GOTO},
    {regex::regex("if"), IF},
    {regex::regex("int"), INT},
    {regex::regex("long"), LONG},
    {regex::regex("register"), REGISTER},
    {regex::regex("return"), RETURN},
    {regex::regex("short"), SHORT},
    {regex::regex("signed"), SIGNED},
    {regex::regex("sizeof"), SIZEOF},
    {regex::regex("static"), STATIC},
    {regex::regex("struct"), STRUCT},
    {regex::regex("switch"), SWITCH},
    {regex::regex("typedef"), TYPEDEF},
    {regex::regex("union"), UNION},
    {regex::regex("unsigned"), UNSIGNED},
    {regex::regex("void"), VOID},
    {regex::regex("volatile"), VOLATILE},
    {regex::regex("while"), WHILE},
    {regex::regex("-"), MINUS},
    {regex::regex("--"), MINUS_MINUS},
    {regex::regex("-="), MINUS_EQUAL},
    {regex::regex("->"), ARROW},
    {regex::regex("!"), BANG},
    {regex::regex("!="), BANG_EQUAL},
    {regex::regex("%"), PERCENT},
    {regex::regex("%="), PERCENT_EQUAL},
    {regex::regex("&"), AMPERSAND},
    {regex::regex("&&"), AMPERSAND_AMPERSAND},
    {regex::regex("&="), AMPERSAND_EQUAL},
    {regex::regex("\\("), LPAREN},
    {regex::regex("\\)"), RPAREN},
    {regex::regex("\\*"), ASTERISK},
    {regex::regex("\\*="), ASTERISK_EQUAL},
    {regex::regex(","), COMMA},
    {regex::regex("."), DOT},
    {regex::regex("/"), SLASH},
    {regex::regex("/="), SLASH_EQUAL},
    {regex::regex(":"), COLON},
    {regex::regex(";"), SEMICOLON},
    {regex::regex("?"), QUESTION},
    {regex::regex("\\["), LBRACKET},
    {regex::regex("\\]"), RBRACKET},
    {regex::regex("^"), CARET},
    {regex::regex("^="), CARET_EQUAL},
    {regex::regex("{"), LBRACE},
    {regex::regex("\\|"), PIPE},
    {regex::regex("\\|\\|"), PIPE_PIPE},
    {regex::regex("\\|="), PIPE_EQUAL},
    {regex::regex("}"), RBRACE},
    {regex::regex("~"), TILDE},
    {regex::regex("\\+"), PLUS},
    {regex::regex("\\+\\+"), PLUS_PLUS},
    {regex::regex("\\+="), PLUS_EQUAL},
    {regex::regex("<"), LESS},
    {regex::regex("<<"), LESS_LESS},
    {regex::regex("<<="), LESS_LESS_EQUAL},
    {regex::regex("<="), LESS_EQUAL},
    {regex::regex("="), EQUAL},
    {regex::regex("=="), EQUAL_EQUAL},
    {regex::regex(">"), GREATER},
    {regex::regex(">="), GREATER_EQUAL},
    {regex::regex(">>"), GREATER_GREATER},
    {regex::regex(">>="), GREATER_GREATER_EQUAL},
    {regex::regex("\""), QUOTE},
    {regex::regex("(//[^\n]*)|(/\\*([^*]|\\*+[^*/])*\\*+/)"), COMMENT},
    {regex::regex("[0-9]+"), NUMBER},
    {regex::regex("[a-zA-Z_%][a-zA-Z0-9_]*"), IDENTIFIER},
    {regex::regex("[ \t\r\n]+"), WHITESPACE}};
} // namespace lexer

#endif // LEXER_KEYWORDS_HPP